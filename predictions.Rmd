---
title: "predictions"
author: "prune"
date: "13/10/2024"
output: html_document
---

##
importation des librairies
```{r}
#prédiction dans un premier temps sur les cinq modèles significatifs avec méthode locf
##########

library(dplyr)#mutate_if et autres
library(lubridate)#transformation datetime
library(ggplot2)#visualisations plot
library(zoo)#moving average et zoo::interp pour les NAs
```

importation et création du dataset 'data'.
```{r}
load("df_modifie.RData")
str(df)#visualisation des variables
df$year <- as.numeric(df$year)
df$month <- as.numeric(df$month)
df$day <- as.numeric(df$day)
df$hour <- as.numeric(df$hour)
df$IQA_numeric <- apply(df[, 20:25], 1, max)#création de la colonne IQA_numeric à partir des IQA individuelles
```

choix de la station
```{r}
liste_des_stations <- levels(df$station)
nom_station <- liste_des_stations[2]#choix de la station
print(paste("station:",nom_station))
data <- df[df$station == nom_station,]
```
##STATION CHANGPING

#méthode de remplissage des NAs locf
```{r}
data <- na.locf(data)#Last Observation Carried Forward package zoo
summary(data)
```

sectionnement du dataset
```{r}
#section du data en deux parties
set.seed(123)
split_index <- floor(0.95 * nrow(data))  # 95% pour train | 15% test
data.train <- data[1:split_index, ]
data.test <- data[(split_index + 1):nrow(data), ]
```

création des variables exogènes
```{r}
require("forecast")

external_vars<-data.train[,c(2:15,17)]#only numerics
mod.arima <- auto.arima(data.train$IQA_numeric, xreg = as.matrix(external_vars))
res1<-summary(mod.arima)
res2<-checkresiduals(mod.arima)
#external_vars_sanstemps<-data[,c(6:15,17)]#only numerics
#mod.arima2 <- auto.arima(data$IQA_numeric, xreg = as.matrix(external_vars_sanstemps))
#res1<-summary(mod.arima2)
#res2<-checkresiduals(mod.arima2)
```

prédiction avec le modèle ARIMA sélectionné par forecast::auto.arima
```{r}
external_vars_test<-data.test[,c(2:15,17)]#only numerics
forecasted_values <- forecast(mod.arima, xreg = as.matrix(external_vars_test))
```

conversion des valeurs numériques prédites en variables catégorielles ("bon", "modéré", "non-sain pour sensibles"...) afin de pouvoir comparer cela avec les vraies valeurs
```{r}
convert_to_IQAs <- function(predictions) {
  sapply(as.numeric(predictions), function(value) {
    if (value <= 50) {
      return("bon")
    } else if (value <= 100) {
      return("modéré")
    } else if (value <= 150) {
      return("non-sain pour sensibles")
    } else if (value <= 200) {
      return("non-sain")
    } else if (value <= 300) {
      return("très non-sain")
    } else {
      return("dangereux")
    }
  })
}
predicted_IQAs <- convert_to_IQAs(forecasted_values$mean)
actual_IQAs <- data.test$IQA
predicted_IQAs <- factor(predicted_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))
actual_IQAs <- factor(actual_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))
```

caret::confusionMatrix pour déterminer l'accuracy du modèle sur différentes plages de temps
```{r}
require("caret")
#prédictions pour le premier jour (24 premières heures)
confusion_matrix24 <- confusionMatrix(as.factor(predicted_IQAs[1:24]), as.factor(actual_IQAs[1:24]))
#prédictions pour les 48h
confusion_matrix48 <- confusionMatrix(as.factor(predicted_IQAs[1:48]), as.factor(actual_IQAs[1:48]))
#prédictions pour les 72h
confusion_matrix72 <- confusionMatrix(as.factor(predicted_IQAs[1:72]), as.factor(actual_IQAs[1:72]))
#prédictions pour la première semaine
confusion_matrix168 <- confusionMatrix(as.factor(predicted_IQAs[1:168]), as.factor(actual_IQAs[1:168]))
#prédictions pour tout le data set data.test
confusion_matrix <- confusionMatrix(as.factor(predicted_IQAs), as.factor(actual_IQAs))

print(confusion_matrix$table)
print(confusion_matrix$byClass)

# Output the confusion matrix
cat(paste("accuracy 24h:", round(confusion_matrix24$overall[1],3),"%",
            "\naccuracy 48h:", round(confusion_matrix48$overall[1],3),"%",
            "\naccuracy 72h:", round(confusion_matrix72$overall[1],3),"%",
            "\naccuracy 168h:", round(confusion_matrix168$overall[1],3),"%",
            "\naccuracy globale:", round(confusion_matrix$overall[1],3),"%"
            ))
```
sensitivity : 
pour les vraies valeurs de [non-sain pour sensibles], le modèle arrive à bien déterminer quand cela est véritablement le cas à [89% du temps]
contrairement, pour [modéré], la sensitivity est faible [29%], car les fois où les vraies valeurs étaient [modéré], le modèle a eu tendance à prédire que ces valeurs étaient beaucoup [non-sain pour sensibles] pour la plupart

specificity :
élevée si à aucun moment le modèle a prédit l'événement alors qu'il n'y en avait pas. 
exemple : specificity pour [class : "bon"] est de [100%] car à aucun moment le modèle a deviné ["bon"] et ce n'était pas le cas. le modèle a simplement jamais prédit ["bon"].

```{r}
for (i in 1:length(summary(data.test$IQA))){
  print(paste(levels(data.test$IQA)[i],":",100*round((summary(data.test$IQA)[i]/length(data.test$IQA)),2),"%"))
}
```
le modèle utilisé ne semble pas adapté à un jeu de données déséquilibré

#accuracy au cours du temps
```{r}
bonne_prediction<-predicted_IQAs==actual_IQAs
acc <- c()
num<-0
for (i in 1:length(bonne_prediction)){
  if (bonne_prediction[i]){#si bonne prédiction
    num <- num+1
    acc<-c(acc,num/i)
  }else{
    acc<-c(acc,num/i)
  }
}
plot(acc)
```
à quoi cette stabilisation de l'accuracy est-elle dû?








#même méthode mais cette fois-ci sans les variables temps (année, mois, jour, heure)
```{r}
external_vars_sanstemps<-data.train[,c(6:15,17)]#only numerics
mod.arima2 <- auto.arima(data.train$IQA_numeric, xreg = as.matrix(external_vars_sanstemps))
res1<-summary(mod.arima2)
res2<-checkresiduals(mod.arima2)
print("avec les variables temps")
print(summary(mod.arima))
print("sans les variables temps")
print(summary(mod.arima2))
```
prédiction
```{r}
external_varssanstemps_test<-data.test[,c(6:15,17)]#only numerics
forecasted_values2 <- forecast(mod.arima2, xreg = as.matrix(external_varssanstemps_test))
predicted_IQAs2 <- convert_to_IQAs(forecasted_values2$mean)
actual_IQAs2 <- data.test$IQA
predicted_IQAs2 <- factor(predicted_IQAs2, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))
actual_IQAs2 <- factor(actual_IQAs2, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))


#matrices de confusions
confusion_matrix24 <- confusionMatrix(as.factor(predicted_IQAs2[1:24]), as.factor(actual_IQAs2[1:24]))
#prédictions pour les 48h
confusion_matrix48 <- confusionMatrix(as.factor(predicted_IQAs2[1:48]), as.factor(actual_IQAs2[1:48]))
#prédictions pour les 72h
confusion_matrix72 <- confusionMatrix(as.factor(predicted_IQAs2[1:72]), as.factor(actual_IQAs2[1:72]))
#prédictions pour la première semaine
confusion_matrix168 <- confusionMatrix(as.factor(predicted_IQAs2[1:168]), as.factor(actual_IQAs2[1:168]))
#prédictions pour tout le data set data.test
confusion_matrix <- confusionMatrix(as.factor(predicted_IQAs2), as.factor(actual_IQAs2))

print(confusion_matrix$table)
print(confusion_matrix$byClass)

# Output the confusion matrix
cat(paste("accuracy 24h:", round(confusion_matrix24$overall[1],3),"%",
            "\naccuracy 48h:", round(confusion_matrix48$overall[1],3),"%",
            "\naccuracy 72h:", round(confusion_matrix72$overall[1],3),"%",
            "\naccuracy 168h:", round(confusion_matrix168$overall[1],3),"%",
            "\naccuracy globale:", round(confusion_matrix$overall[1],3),"%"
            ))

#équilibre et poids des variables 
for (i in 1:length(summary(data.test$IQA))){
  print(paste(levels(data.test$IQA)[i],":",100*round((summary(data.test$IQA)[i]/length(data.test$IQA)),2),"%"))
}

bonne_prediction<-predicted_IQAs2==actual_IQAs2
acc2 <- c()
num<-0
for (i in 1:length(bonne_prediction)){
  if (bonne_prediction[i]){#si bonne prédiction
    num <- num+1
    acc2<-c(acc2,num/i)
  }else{
    acc2<-c(acc2,num/i)
  }
}
plot(acc2)
```



#méthode de remplissage des NAs interp. station : Changping
```{r}
liste_des_stations <- levels(df$station)
nom_station <- liste_des_stations[2]#choix de la station
data <- df[df$station == nom_station,]

numeric_cols <- sapply(data, is.numeric)
data[numeric_cols] <- lapply(data[numeric_cols], function(column) {
  na.interp(column)
})
summary(data)
```


```{r}
external_vars<-data.train[,c(2:15,17)]#only numerics
mod.arima <- auto.arima(data.train$IQA_numeric, xreg = as.matrix(external_vars))
summary(mod.arima)
checkresiduals(mod.arima)
external_vars_test<-data.test[,c(2:15,17)]#only numerics
forecasted_values <- forecast(mod.arima, xreg = as.matrix(external_vars_test))
predicted_IQAs <- convert_to_IQAs(forecasted_values$mean)
actual_IQAs <- data.test$IQA
predicted_IQAs <- factor(predicted_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))
actual_IQAs <- factor(actual_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))


#prédictions pour le premier jour (24 premières heures)
confusion_matrix24 <- confusionMatrix(as.factor(predicted_IQAs[1:24]), as.factor(actual_IQAs[1:24]))
#prédictions pour les 48h
confusion_matrix48 <- confusionMatrix(as.factor(predicted_IQAs[1:48]), as.factor(actual_IQAs[1:48]))
#prédictions pour les 72h
confusion_matrix72 <- confusionMatrix(as.factor(predicted_IQAs[1:72]), as.factor(actual_IQAs[1:72]))
#prédictions pour la première semaine
confusion_matrix168 <- confusionMatrix(as.factor(predicted_IQAs[1:168]), as.factor(actual_IQAs[1:168]))
#prédictions pour tout le data set data.test
confusion_matrix <- confusionMatrix(as.factor(predicted_IQAs), as.factor(actual_IQAs))

print(confusion_matrix$table)
print(confusion_matrix$byClass)

# Output the confusion matrix
cat(paste("accuracy 24h:", round(confusion_matrix24$overall[1],3),"%",
            "\naccuracy 48h:", round(confusion_matrix48$overall[1],3),"%",
            "\naccuracy 72h:", round(confusion_matrix72$overall[1],3),"%",
            "\naccuracy 168h:", round(confusion_matrix168$overall[1],3),"%",
            "\naccuracy globale:", round(confusion_matrix$overall[1],3),"%"
            ))


bonne_prediction<-predicted_IQAs==actual_IQAs
acc <- c()
num<-0
for (i in 1:length(bonne_prediction)){
  if (bonne_prediction[i]){#si bonne prédiction
    num <- num+1
    acc<-c(acc,num/i)
  }else{
    acc<-c(acc,num/i)
  }
}
plot(acc)
```
#avec NAs
#méthode de remplissage des NAs interp. station : Changping
```{r}
liste_des_stations <- levels(df$station)
nom_station <- liste_des_stations[2]#choix de la station
data <- df[df$station == nom_station,]
summary(data)

#section du data en deux parties
set.seed(123)
split_index <- floor(0.95 * nrow(data))  # 90% pour train | 10% test
data.train <- data[1:split_index, ]
data.test <- data[(split_index + 1):nrow(data), ]
```



```{r}
external_vars<-data.train[,c(2:15,17)]#only numerics
mod.arima <- auto.arima(data.train$IQA_numeric, xreg = as.matrix(external_vars))
summary(mod.arima)
checkresiduals(mod.arima)
external_vars_test<-data.test[,c(2:15,17)]#only numerics
forecasted_values <- forecast(mod.arima, xreg = as.matrix(external_vars_test))
predicted_IQAs <- convert_to_IQAs(!is.na(forecasted_values$mean))
actual_IQAs <- data.test$IQA
predicted_IQAs <- factor(predicted_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))
actual_IQAs <- factor(actual_IQAs, levels = c("bon", "modéré", "non-sain pour sensibles", "non-sain", "très non-sain", "dangereux"))


#prédictions pour le premier jour (24 premières heures)
confusion_matrix24 <- confusionMatrix(as.factor(predicted_IQAs[1:24]), as.factor(actual_IQAs[1:24]))
#prédictions pour les 48h
confusion_matrix48 <- confusionMatrix(as.factor(predicted_IQAs[1:48]), as.factor(actual_IQAs[1:48]))
#prédictions pour les 72h
confusion_matrix72 <- confusionMatrix(as.factor(predicted_IQAs[1:72]), as.factor(actual_IQAs[1:72]))
#prédictions pour la première semaine
confusion_matrix168 <- confusionMatrix(as.factor(predicted_IQAs[1:168]), as.factor(actual_IQAs[1:168]))
#prédictions pour tout le data set data.test
confusion_matrix <- confusionMatrix(as.factor(predicted_IQAs), as.factor(actual_IQAs))

print(confusion_matrix$table)
print(confusion_matrix$byClass)

# Output the confusion matrix
cat(paste("accuracy 24h:", round(confusion_matrix24$overall[1],3),"%",
            "\naccuracy 48h:", round(confusion_matrix48$overall[1],3),"%",
            "\naccuracy 72h:", round(confusion_matrix72$overall[1],3),"%",
            "\naccuracy 168h:", round(confusion_matrix168$overall[1],3),"%",
            "\naccuracy globale:", round(confusion_matrix$overall[1],3),"%"
            ))

for (i in 1:length(summary(data.test$IQA))){
  print(paste(levels(data.test$IQA)[i],":",round(100*(summary(data.test$IQA)[i]/length(data.test$IQA)),2),"%"))
}

bonne_prediction<-predicted_IQAs==actual_IQAs
acc <- c()
num<-0
for (i in 1:length(bonne_prediction)){
  if (!is.na(bonne_prediction[i])){#si valeure != NA
    if (bonne_prediction[i]){#si bonne prédiction
    num <- num+1
    acc<-c(acc,num/i)
  }else{
    acc<-c(acc,num/i)
  }
  }else{#si valeur == NA
    acc<-c(acc)
  }
}
plot(acc)
```

comparaison avec station Huairou
##STATION HUAIROU
```{r}

```

comparaison avec station Nongzhanguan
##STATION NONGZHANGUAN

#prédiction sur polluant